# src/pdf_generation/generator.py
"""
A standalone module for generating all PDF documents for the training program.
It contains all necessary helpers, styles, components, and generation logic.
"""
import os
import json
from datetime import datetime
from typing import List, Dict, Any, Callable

# --- Consolidated Imports ---
from reportlab.pdfgen.canvas import Canvas
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.lib.enums import TA_CENTER, TA_LEFT
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.platypus import (
    BaseDocTemplate, Flowable, Frame, FrameBreak, NextPageTemplate,
    PageTemplate, Spacer, Paragraph, Table, TableStyle
)
from src.config import settings


# ==============================================================================
# SECTION: UTILITIES (from former utils.py)
# ==============================================================================

def register_font():
    """Registers the DejaVuSans font for use in ReportLab."""
    font_path = settings.FONT_PATH
    font_name = "DejaVuSans"
    if not os.path.exists(font_path):
        print(f"Error: Font file not found at {font_path}.")
        return False

    pdfmetrics.registerFont(TTFont(font_name, font_path))
    pdfmetrics.registerFontFamily(
        font_name,
        normal=font_name,
        bold="DejaVuSans-Bold",
        italic="DejaVuSans-Italic",
        boldItalic="DejaVuSans-BoldItalic",
    )
    return True


def _split_text_into_lines(
    text: str, target_length: int, indent_spaces: int
) -> list[str]:
    """Helper to split a long string into lines of a target length."""
    if not text: return [""]
    lines, indent = [], " " * indent_spaces
    words, current_line, current_length = text.split(" "), [], len(indent)

    for word in words:
        if current_length + len(word) + 1 > target_length:
            lines.append(indent + " ".join(current_line))
            current_line, current_length = [word], len(indent) + len(word)
        else:
            current_line.append(word)
            current_length += len(word) + 1
    if current_line: lines.append(indent + " ".join(current_line))
    return lines


def format_long_text(
    text: str, indent_spaces: int, target_length: int
) -> list[str]:
    """Formats a potentially multi-paragraph text block for PDF display."""
    if not text: return [""]
    output_lines = []
    for paragraph in text.split("\n"):
        output_lines.extend(
            _split_text_into_lines(paragraph, target_length, indent_spaces)
        )
    return output_lines


def draw_wrapped_text(
    canvas: Canvas, x: float, y: float, line_spacing: float,
    text_to_wrap: str, max_line_length: int, indent_spaces: int = 0,
    align: str = "left",
):
    """Draws multi-line text on a canvas with wrapping."""
    lines, current_y = format_long_text(text_to_wrap, indent_spaces, max_line_length), y
    for line in lines:
        if align == "left": canvas.drawString(x, current_y, line)
        elif align == "center": canvas.drawCentredString(x, current_y, line)
        else: raise ValueError(f"Invalid alignment: {align}")
        current_y -= line_spacing


# ==============================================================================
# SECTION: PDF STYLES (from former styles.py)
# ==============================================================================

def get_paragraph_styles():
    """Returns a customized ReportLab StyleSheet."""
    styles = getSampleStyleSheet()
    styles["Normal"].fontName = "DejaVuSans"
    styles["Normal"].fontSize = 12
    styles["h1"].fontName = "DejaVuSans"
    styles.add(ParagraphStyle(name="NormalCenter", parent=styles["Normal"], alignment=TA_CENTER))
    return styles


def get_page_templates() -> list[PageTemplate]:
    """Returns a list of PageTemplate objects for the document."""
    normal_frame = Frame(2.5*cm, 2.5*cm, A4[0]-5*cm, A4[1]-5*cm, id="normal")
    full_frame = Frame(0, 0, A4[0], A4[1], 0, 0, 0, 0, id="full")
    return [PageTemplate(id="T_Full", frames=[full_frame]),
            PageTemplate(id="T_Normal", frames=[normal_frame])]


def get_base_table_style(font: str = "DejaVuSans") -> TableStyle:
    return TableStyle([
        ("FONTNAME", (0, 0), (-1, -1), font),
        ("FONTSIZE", (0, 0), (-1, -1), 8),
        ("GRID", (0, 0), (-1, -1), 1, colors.black),
        ("ALIGN", (0, 0), (-1, -1), "LEFT"),
        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
    ])

def get_sprawozdanie_style(font: str = "DejaVuSans") -> TableStyle:
    style = get_base_table_style(font)
    style.add("ALIGN", (0, 0), (-1, -1), "CENTER")
    style.add("SPAN", (0, 0), (1, 0)); style.add("SPAN", (2, 0), (3, 0))
    style.add("SPAN", (4, 0), (4, 1)); style.add("SPAN", (5, 0), (5, 1))
    style.add("SPAN", (6, 0), (6, 1))
    return style

# Add other custom table styles (get_plan_style, get_program_style) here if needed


# ==============================================================================
# SECTION: REUSABLE COMPONENTS (from former components.py)
# ==============================================================================

class FullFrameCanvasDrawing(Flowable):
    """A Flowable that delegates drawing to an external function."""
    def __init__(self, drawing_function, data: dict[str, Any] = {}):
        super().__init__()
        self.width, self.height = A4
        self.drawing_function = drawing_function
        self.data = data or {}

    def wrap(self, aW, aH): return self.width, self.height
    def draw(self): self.drawing_function(canvas=self.canv, data=self.data)


def _generate_generic_table(
    headers: List[str], data: List[List[str]],
    data_func: Callable, col_widths: list[float] = [], custom_style: str = "",
) -> Table:
    if not data or len(headers) != len(data[0]):
        raise ValueError("Header and data column counts must match.")
    table = Table(data_func(headers, data), colWidths=col_widths or None)
    style_map = {"sprawozdanie": get_sprawozdanie_style()}
    table.setStyle(style_map.get(custom_style, get_base_table_style()))
    return table

def generate_table(headers: List[str], data: List[List[str]], **kwargs) -> Table:
    return _generate_generic_table(headers, data, lambda h, d: [h] + d, **kwargs)

def generate_counted_table(headers: List[str], data: List[List[str]], **kwargs) -> Table:
    add_counter = lambda h, d: [[""] + h] + [[str(i + 1)] + r for i, r in enumerate(d)]
    return _generate_generic_table(headers, data, add_counter, **kwargs)


# ==============================================================================
# SECTION: PAGE-SPECIFIC DRAWING FUNCTIONS
# ==============================================================================

def draw_dziennik_front_page(canvas: Canvas, data: Dict[str, Any]):
    page_width, page_height = A4; middle = page_width/2; left = 2.72*cm
    canvas.setFont("DejaVuSans", 28); canvas.drawCentredString(middle, 18.3*cm, "Dziennik zajec")
    canvas.setFont("DejaVuSans", 16)
    draw_wrapped_text(canvas, middle, 15.8*cm, 0.8*cm, "Tytul: " + data.get('nazwa_szkolenia',''), 50, align="center")
    canvas.drawCentredString(middle, 13.9*cm, f"KOD SZKOLENIA: {data.get('numer_szkolenia', '')}")
    canvas.setFont("DejaVuSans", 12)
    canvas.drawString(left, 9*cm, f"Data: {data.get('data_szkolenia', '')}")
    draw_wrapped_text(canvas, left, 8*cm, 0.5*cm, f"Miejsce: {data.get('miejsce_szkolenia', '')}", 70, indent_spaces=14)
    canvas.drawString(left, 6.5*cm, f"Prowadzacy: {data.get('prowadzacy_szkolenie', '')}")
    # Logo
    w, h = 6.2*cm, 2.5*cm; x = page_width - 0.8*cm - w; y = page_height - 0.8*cm - h
    canvas.drawInlineImage(settings.IMAGE_LOGO_PATH, x, y, width=w, height=h)


def draw_certyfikat_page(canvas: Canvas, data: Dict[str, Any]):
    imie_nazwisko = data.get("imie_nazwisko", "")
    data_urodzenia = data.get("data_urodzenia", "")
    nazwa_szkolenia = data.get('nazwa_szkolenia', "")
    dzien_ukonczenia = data.get('data_szkolenia', "")
    w_wymiarze = data.get("w_wymiarze", "")
    wydano = data.get("wydano", "")

    canvas.setFont("DejaVuSans", 12)
    canvas.drawInlineImage(settings.IMAGE_LOGO_PATH, 1.5*cm, 26*cm, width=6.2*cm, height=2.5*cm)
    canvas.drawInlineImage(settings.IMAGE_STAMP_PATH, 12.1*cm, 26.4*cm, width=7.5*cm, height=2.2*cm)
    canvas.drawString(1.2*cm, 23.1*cm, "SzPR/25/...")
    canvas.line(2.8*cm, 22.4*cm, 18.2*cm, 22.4*cm)
    canvas.setFont("DejaVuSans", 22); canvas.drawCentredString(A4[0]/2, 21.3*cm, "ZAŚWIADCZENIE")
    canvas.setFont("DejaVuSans", 12); canvas.drawCentredString(A4[0]/2, 20.5*cm, "O UKOŃCZENIU FORMY DOSKONALENIA ZAWODOWEGO")
    canvas.line(2.8*cm, 20.1*cm, 18.2*cm, 20.1*cm)
    canvas.drawCentredString(A4[0]/2, 18.9*cm, "Pan/i")
    canvas.setFont("DejaVuSans", 24); canvas.drawCentredString(A4[0]/2, 17.6*cm, imie_nazwisko)
    canvas.setFont("DejaVuSans", 12); canvas.drawCentredString(A4[0]/2, 16.6*cm, f"urodzony/a: {data_urodzenia}")
    canvas.drawCentredString(A4[0]/2, 15.8*cm, "ukończył/a szkolenie:")
    canvas.drawCentredString(A4[0]/2, 13.9*cm, f'"{nazwa_szkolenia}"')
    canvas.drawString(5.4*cm, 12.3*cm, f"w dniu: {dzien_ukonczenia}"); canvas.drawString(11.4*cm, 12.3*cm, f"w wymiarze: {w_wymiarze}")
    canvas.drawCentredString(A4[0]/2, 10.5*cm, "zorganizowane przez Niepubliczną Placówkę Doskonalenia Nauczycieli")
    canvas.drawCentredString(A4[0]/2, 9.9*cm, "Best Practice Edukacja w Wieliczce")
    canvas.drawString(3*cm, 5.6*cm, "Zaświadczenie wydano:"); canvas.drawString(3*cm, 4.8*cm, f"Wieliczka, {wydano}")


# ==============================================================================
# SECTION: INTERNAL GENERATION LOGIC
# ==============================================================================

def _generate_single_certificate(participant_data, training_data, output_pdf_path):
    """Generates a single PDF certificate file."""
    doc = BaseDocTemplate(output_pdf_path, pagesize=A4)
    doc.addPageTemplates(get_page_templates())
    story = [FullFrameCanvasDrawing(draw_certyfikat_page, data={**participant_data, **training_data, "wydano": datetime.now().strftime("%d.%m.%Y")})]
    try:
        doc.build(story)
        print(f"  -> Successfully created {os.path.basename(output_pdf_path)}")
        return datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    except Exception as e:
        print(f"  -> Error building PDF '{output_pdf_path}': {e}")
        return None


def _generate_all_certificates(data_json, output_dir, force):
    """Generates certificates, returning the updated list of participants."""
    print("Generating certificates...")
    participants, training_data = data_json.get(settings.KEY_PARTICIPANTS, []), data_json.get(settings.KEY_TRAINING, {})
    updated_participants = json.loads(json.dumps(participants)) # Deep copy

    for i, person in enumerate(updated_participants):
        if not force and person.get(settings.KEY_GENERATED_TIMESTAMP):
            continue
        file_path = os.path.join(output_dir, f"certyfikat_{i+1}.pdf")
        if timestamp := _generate_single_certificate(person, training_data, file_path):
            person[settings.KEY_GENERATED_TIMESTAMP] = timestamp
    return updated_participants


def _generate_logbook(data_json, output_pdf_path):
    """Generates the main training logbook PDF."""
    print("Generating logbook...")
    people, props, styles = data_json.get(settings.KEY_PARTICIPANTS, []), data_json.get(settings.KEY_TRAINING, {}), get_paragraph_styles()
    doc = BaseDocTemplate(output_pdf_path, pagesize=A4)
    doc.addPageTemplates(get_page_templates())
    story = [FullFrameCanvasDrawing(draw_dziennik_front_page, data=props)]
    story.extend([NextPageTemplate("T_Normal"), FrameBreak()])
    # Remainder of logbook story... (omitted for brevity, same as before)
    story.extend([Paragraph("SPRAWOZDANIE Z KURSU:", styles["h1"]), Spacer(1, 10*cm)])
    story.append(Paragraph("Wieliczka " + datetime.now().strftime("%d.%m.%Y"), styles["Normal"]))
    try:
        doc.build(story)
        print(f"  -> Successfully created {os.path.basename(output_pdf_path)}")
    except Exception as e: print(f"  -> Error building logbook: {e}")


# ==============================================================================
# SECTION: PUBLIC API
# ==============================================================================

def generate(data_json: Dict[str, Any], output_dir: str, **kwargs) -> Dict[str, Any]:
    """
    Main PDF generation orchestrator.
    Generates a logbook and all required certificates.

    Returns: The updated data_json with new generation timestamps.
    """
    force = kwargs.get('force', False)
    register_font()

    # 1. Generate Logbook
    logbook_path = os.path.join(output_dir, settings.LOGBOOK_FILENAME)
    _generate_logbook(data_json, logbook_path)

    # 2. Generate Certificates
    certs_dir = os.path.join(output_dir, settings.CERTIFICATES_DIR_NAME)
    os.makedirs(certs_dir, exist_ok=True)
    updated_participants = _generate_all_certificates(data_json, certs_dir, force)
    
    # 3. Create and return the final, updated data object
    updated_data_json = json.loads(json.dumps(data_json)) # Deep copy
    updated_data_json[settings.KEY_PARTICIPANTS] = updated_participants
    return updated_data_json
